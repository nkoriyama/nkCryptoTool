## nkCryptoTool 高速化の秘訣

`nkCryptoTool` は、特に大容量ファイルの暗号化・復号において高いパフォーマンスを発揮します。その高速化の秘訣は、現代のC++の機能と効率的なライブラリを組み合わせた、以下の設計と実装にあります。

### 1. 非同期I/Oパイプライン処理

*   **I/Oボトルネックの回避**: 大容量ファイルの処理では、ディスクI/Oがボトルネックになりがちです。`nkCryptoTool` は、ファイルを一度にすべてメモリに読み込むのではなく、小さなチャンク（`CHUNK_SIZE`）に分割して非同期的に処理するパイプライン方式を採用しています。
*   **並行処理の最大化**: データの読み込み、暗号化/復号、書き込みといった各ステージが非同期的に動作し、互いにブロックすることなく並行して進行します。これにより、I/O待ちの時間を有効活用し、CPUのアイドル時間を最小限に抑えます。

#### パイプライン処理の心臓部：キューとマップによる並列化と順序保証

このプログラムの心臓部は、**非同期I/Oライブラリ Asio** を利用して構築された、高度なパイプラインです。単純な `Reader -> Processor -> Writer` という流れではなく、複数のワーカースレッドによる並列処理を最大限に活かしつつ、データの順序を保証するために、**キュー (`std::queue`)** と **マップ (`std::map`)** という2つの重要なデータ構造を駆使しています。

#### アーキテクチャ図

```mermaid
graph TD
    A["<b>ファイル読み込み (Reader)</b><br>asio::async_read_some"] -- "① チャンクをタスク化" --> Q(["<b>task_queue_</b><br>(std::queue)"])

    subgraph "ワーカースレッドプール (Processor)"
        direction LR
        W1["Worker 1"]
        W2["Worker 2"]
        W3["..."]
        W4["Worker N"]
    end

    Q -- "② タスクを取得" --> W1
    Q -- "② タスクを取得" --> W2
    Q -- "② タスクを取得" --> W3
    Q -- "② タスクを取得" --> W4

    W1 -- "③ 暗号化/復号" --> M(["<b>results_map_</b><br>(std::map)"])
    W2 -- "③ 暗号化/復号" --> M
    W3 -- "③ 暗号化/復号" --> M
    W4 -- "③ 暗号化/復号" --> M

    M -- "④ 順序通りに結果を取得" --> C["<b>ファイル書き込み (Writer)</b><br>asio::async_write"]

    C -- "⑤ ファイルに書き込み" --> D(("完了"))
```

#### 各コンポーネントの役割

1.  **ファイル読み込み (Reader)**:
    *   非同期I/O (`asio::async_read_some`) を使って、ファイルを小さなチャンク単位で読み込みます。
    *   読み込んだチャンクに**一意の連番（順序キー）**を付与し、タスクとして `task_queue_` に追加します。

2.  **タスクキュー (`task_queue_`)**:
    *   `std::queue` で実装された、スレッドセーフなキューです。
    *   Readerによって生成された未処理のタスクを一時的に保持します。
    *   ワーカースレッドとReaderの間の**バッファ**として機能し、処理速度の差を吸収します。

3.  **ワーカースレッドプール (Processor)**:
    *   CPUコア数に応じた数のスレッド (`std::thread`) が待機しています。
    *   各ワーカースレッドは、`task_queue_` からタスクを一つ取り出し、担当の暗号化・復号処理を実行します。
    *   処理が完了すると、結果のデータチャンクを、タスクが持っていた**順序キー**と共に `results_map_` に格納します。

4.  **結果マップ (`results_map_`)**:
    *   `std::map` で実装された、順序キーでソートされるスレッドセーフなマップです。
    *   ワーカースレッドによる処理は並列で行われるため、完了の順序はバラバラになります。このマップは、順不同で到着する処理済みチャンクを、**正しい順序に並べ替える**ためのバッファとして機能します。

5.  **ファイル書き込み (Writer)**:
    *   非同期コルーチンとして実装されています。
    *   `results_map_` を監視し、書き込むべき次の順序キー（例: 0, 1, 2, ...）のデータが存在するかをチェックします。
    *   データが存在すれば、それを取り出して非同期にファイル (`asio::async_write`) に書き込み、次の順序キーのデータを待ちます。

このアーキテクチャにより、CPU処理（暗号化）とディスクI/O（読み書き）が効率的に並列化されるだけでなく、処理結果の順序も正確に保証され、高いパフォーマンスと信頼性を両立しています。

### 2. C++20 コルーチン (`asio::awaitable`)

*   **非同期処理の簡潔な記述**: C++20で標準化されたコルーチン機能（Asioライブラリでは `asio::awaitable` として提供）を全面的に採用しています。これにより、複雑なコールバックチェーンを避け、非同期処理のロジックを同期コードのように直線的かつ読みやすく記述できます。
*   **スレッドの非チャンク化**: `co_await` を使用することで、I/O操作の完了を待つ間、現在のコルーチンは実行を一時停止し、CPUの制御を `asio::io_context` に戻します。これにより、スレッドはチャンクされることなく、他の準備ができたタスクを実行できるため、スレッドリソースの利用効率が向上します。

### 3. `asio::io_context` とマルチスレッド

*   **効率的なタスクスケジューリング**: `asio::io_context` は、非同期操作の完了イベントを管理し、完了したタスク（コルーチンを含む）をキューに格納します。
*   **真の並列実行**: `nkCryptoTool` は、`asio::io_context` を複数のスレッドで実行することで、`io_context` のキューにあるタスクを複数のCPUコアに分散して実行させます。これにより、コルーチンによる並行処理と、複数のCPUコアによる真の並列処理の両方の恩恵を受け、CPUリソースを最大限に活用しています。
*   **軽量な並行性**: コルーチン自体はスレッドよりもはるかに軽量であるため、多数の並行タスクを効率的に管理し、スレッド生成やコンテキストスイッチのオーバーヘッドを最小限に抑えることができます。

### 4. 暗号化アルゴリズムの効率的な選択と実装

*   **Hybridモードの最適化**: ベンチマーク結果から、特に大容量ファイルにおいてHybridモードが最も高いスループットを発揮することが示されました。これは、PQCとECCの組み合わせが、`nkCryptoTool` のパイプライン処理と相まって、効率的なデータ処理を実現していることを示唆しています。
*   **OpenSSLの活用**: 高性能な暗号化処理のために、最適化されたOpenSSLライブラリをバックエンドとして利用しています。

### 5. コンパイラ最適化フラグ

*   `CMakeLists.txt` で `-O3` (最大最適化)、`-march=native` (CPU固有の命令セット活用)、`-mtune=native` (CPUアーキテクチャに最適化)、`-flto` (リンク時最適化)、`-funroll-loops` (ループ展開) などのコンパイラ最適化フラグが設定されています。これにより、生成される実行ファイルのパフォーマンスが最大限に引き出されます。

これらの要素が複合的に作用することで、`nkCryptoTool` は大容量ファイルの暗号化・復号において優れたパフォーマンスを実現しています。
